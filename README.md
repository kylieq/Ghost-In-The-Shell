# Ghost-In-The-Shell
For this project, I implemented an MCP such that multiple workload programs may be run and scheduled on the system. In doing so, the user must provide an input file that contains the names of the programs and their arguments. These commands will be executed concurrently within the four parts of this project. 

For the first part of the project, the MCP creates child processes in which each child process is assigned a command from the input file. While each child process executes its corresponding workload program, the MCP must wait before exiting. This wait is required in the second part of the project as well. 

In addition to the wait requirement, we use signals in the second part of the project to further control the execution of the child processes. The first signal the MCP sends to each of its child processes is SIGUSR1. Each child process is to wait for this signal before executing its corresponding workload program. Once SIGUSR1 is received, it may resume execution. The other signals that are sent to the child processes are SIGSTOP and SIGCONT. When the child processes receive the SIGSTOP signal, they are in a suspended state such that they are unable to do anything. However, once they receive the SIGCONT signal, they may resume running. As is expected of the first part of the project, each process must be suspended before any process may resume running. The MCP then waits for each child process to terminate before exiting.

The third part of the project enforces stricter scheduling rules similar to that of the round-robin scheduling algorithm. A FIFO queue must be implemented to preserve an order in which the child processes are to run. For starters, the MCP must suspend all child processes except for the first process in the queue. Once these processes are suspended, the MCP sends a SIGALRM signal. This signal indicates to the MCP itself that it may begin scheduling the child processes to continue running concurrently in a round-robin style. The way this is done is the MCP will suspend execution for the first child process in the queue, since it is already currently running. Next, it will resume execution for the next child process in the queue. There is a pattern of suspending the currently running child process and then resuming the execution for the child process next lined up in the queue. This goes on until each child process has terminated. Once each child process has finished executing, the MCP may exit.

The additional functionality provided by the fourth part of the project is a list of data from /proc  regarding which system resources each child process is using. This is a simplified version of the Linux top command.
